\subsection{Общий принцип ГА}\label{subsec:ga_general_principles}
Идея работы Генетического алгоритма заимствована у природы.

Точно также, как в ходе эволюции происходит появление оптимального организма для заданных условий,
в ходе работы алгоритма ищется набор параметров функции, при котором фитнесс-функция максимальна.

В природе тот, кто лучше приспособлен к окружающей среде, в большей степени получает доступ к размножению (с помощью различных механизмов),
а при размножении новая особь наследует признаки каждого из родителей.

Это позволяет именно лучшим чертам, по каким-либо причинам появившихся у особей, переходить в следующее поколение.
Эти черты появляются через мутации — небольшие случайные изменения в геноме.

Из принципа работы можно понять, что алгоритм \href{https://en.wikipedia.org/wiki/Heuristic_(computer_science)}{эвристический}: сложно доказать его сходимость или что-либо гарантировать с вероятностью 100\%.
Зато \href{talgat.org/news/wp-content/uploads/2018/08/112.pdf}{исследования} показывают, что именно этот алгоритм даёт лучшие результаты для самых сложных функций.
В разделе \ref{subsubsec:hazing}, какие меры предпринимаются, чтобы не дать алгоритму попасть в локальный минимум, не добравшись до глобального.

\subsection{Термины}\label{subsec:ga_principles}
Набор параметров представляется в виде \textit{«генома»} — некой структуры данных, содержащей информацию об этом наборе.
\textit{Особь} — в контексте алгоритма будет использоваться в качестве синонима к геному.
Геном состоит изх \textit{генов} — каждый из них содержит информацию о каком-либо признаке (в случае природы) или параметре (в случае ГА).

В каждый момент времени алгоритм работает с \textit{популяцией} — набором геномов.
Полный аналог популяции в природе.
Мутация — как и в реальной жизни — небольшое случайное изменение генома без строго определённого направления.

\subsection{Примерная последовательность действий ГА}\label{subsec:approx_ga_algo}
В общих чертах работа ГА выглядит так:

\underline{Инициализация}: Сгенерировать случайную популяцию, каждый ген каждого генома — в заданных пределах.

Затем — повторять, пока не закончится заданное количество итераций или не будет достигнуто требуемое значение фитнесс-функции:
\begin{enumerate}
    \item Посчитать фитнесс-функции для каждой из особей.
    Для большинства задач этот шаг занимает бо́льшую часть времени исполнения, поэтому нужно оптимизировать именно его, в частности — параллелизовать, запуская независимые вычисления на нескольких потоках.
    \item Каким-то образом отобрать особи на скрещивание
    \item Произвести скрещивание, получив «отпрысков» — часть нового поколения
    \item Сформировать новое поколение, используя, возможно, в разных пропорциях, различные источники геномов, а именно:
            \begin{itemize}
                \item Отпрысков, полученных на предыдущем шаге в результате скрещивания
                \item Лучшие особи из прошлой популяции
                \item Случайные особи —  чтобы не дать алгоритму сойтись раньше времени, попав в локальный минимум
                \item Возможно, результаты скрещивания особей в числе больше 2
            \end{itemize}
    \item Произвести мутации в некоторых особях этого поколения (лучшие из мутаций внедрятся в популяцию на следующих итерациях)
    \item Если алгоритм подходит к концу, добавить лучший геном из предыдущего поколения (чтобы он не подвергся мутации)
\end{enumerate}

\subsection{Авторские Модификации  в ГА}\label{sec:my_modifications}

Учитывая тот факт, что в большинстве задач, решаемых мною, бо́льшая часть вычислительного времени ($\gg 95\%$) используется для подсчёта функции ошибки, а не для маниппуляций с геномами
(это подтверждается результатами профайлинга).
То есть задача состоит в том, чтобы минимизировать количество подсчётов функции ошибки, даже ценой более долгой работы с геномами.

Первое изменение — я решил отказаться от дискретного кодирования геномов.
Для алгоритма по каждой переменной задан её диапазон.

Традиционный подход — разделить диапазон на $2^N$ частей и кодировать номер части в геноме как битовую последовательность из $N$ бит.
Для подсчёта функции ошибки этот номер перекодируется назад в соответствующую точку непрерывной величины.
Мутацей в данном случае является изменение случайного количества каких-то битов этого номера.
А скрещивание обычно происходит путём

Предварительное тестирование показало бо́льшую эффективность этого метода по сравнению с традиционным подходом, однако планируется провести тщательное тестирование (см. \ref{itm:testing_system})

\subsubsection{hazing\_percent: скорость сходимости}\label{subsubsec:hazing}
Соотношение элит
Нужно исследовать всю область поиска, для этого нужно не давать сразу огромный бонус при размножении и переходе в другое поколение за некоторое преимущество.
Так получится обеспечить развитие нескольких «очагов», внутри которых и будет происходить «шлифование» «идеи искать в этой области».
% TODO: Лучше описать это

Алгоритм реализован мной на языке C++, он хранится в GitHub репозитории \href{https://github.com/donRumata03/PowerfulGA}{https://github.com/donRumata03/PowerfulGA}.