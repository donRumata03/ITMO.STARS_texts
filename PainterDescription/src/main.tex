%! Author = Vova
%! Date = 13.07.2021

% Preamble
\documentclass[11pt]{article}


% Packages
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{polyglossia}
\usepackage{graphicx}
\usepackage{babel,blindtext}


% Language and Font settings

% Kurale
% New Standard Old

\setdefaultlanguage{russian}
\setmainfont[Ligatures=TeX]{New Standard Old}
\newfontfamily\cyrillicfont{New Standard Old}[Script=Cyrillic]

\title{Описание программной части робота-художника}
\author{Латыпов Владимир Витальевич}
\date{\today}

% Document
\begin{document}
    \maketitle



    \section{Формулировка задачи}

    Для того, чтобы робот-художник нарисовал что-либо, ему нужно предоставить данные в определённом формате, а именно — не набор пикселей,
    как требуется для показа на мониторе, а набор «мазков»: это связано с конструкцией самого робота.
    Мазки решено было представлять в виде кривых безье второго порядка (то есть квадратичных), к которым добавлены параметры «толщина» и «цвет».

    Но на вход подаются рисунки не в векторном, а в растровом формате.
    Найти такую комбинацию мазков, которая бы лучше всего соответствовала картине/изображению — задача нетривиальная, имеющая множество решений.

    Поэтому решено было использовать эвристические алгоритмы оптимизации:
    \href{https://en.wikipedia.org/wiki/Simulated_annealing}{Генетический алгоритм} и \href{https://en.wikipedia.org/wiki/Simulated_annealing}{Симуляция отжига}.

    Функцию ошибки необходимо задать таким образом, чтобы она отражала качество полученной комбинации мазков,
    причём в любой точке направление её уменьшения соответствовало направлению улучшения результата.
    Помимо напрашивающегося \href{https://en.wikipedia.org/wiki/Mean_squared_error}{MSE}, используемого

    \begin{equation}\label{eq:equation}
        MSE = \sum_{y = 0}^{y < height} { \sum_{x = 0}^{x < width} { \sum_{c \in  \left\{ r, g, b \right\} } { \left( {\overrightarrow {rendered_{x, y}}}_c - {\overrightarrow{original_{x, y}}}_c\right)^2 }}}
    \end{equation}


    \section {Алгоритмы оптимизации}

    \subsection{Общий принцип ГА}
    Идея работы Генетического алгоритма заимствована у природы.
    Точно также, как в ходе эволюции происходит появление оптимального организма для заданных условий,
    в ходе работы алгоритма ищется набор параметров функции, при котором фитнесс-функция максимальна.
    В природе тот, кто лучше приспособлен к окружающей среде, в большей степени получает доступ к размножению (с помощью различных механизмов),
    а при размножении новая особь наследует признаки каждого из родителей.
    Это позволяет именно лучшим чертам, по каким-либо причинам появившихся у особей, переходить в следующее поколение.
    Эти черты появляются через мутации — небольшие случайные изменения в геноме.

    Из принципа работы можно понять, что алгоритм \href{https://en.wikipedia.org/wiki/Heuristic_(computer_science)}{эвристический}: сложно доказать его сходимость или что-либо гарантировать с вероятностью 100\%.
    Зато исследования (ДОРБАВИТЬ ССЫЛКИ) показывают, что именно этот алгоритм даёт лучшие результаты для самых сложных функций.
    Далее мы увидим, какие меры предпринимаются, чтобы не дать алгоритму попасть в локальный минимум, не добравшись до глобального.

    \subsection{Термины}
    Набор параметров представляется в виде \textit{«генома»} — некой структуры данных, содержащей информацию об этом наборе.
    \textit{Особь} — в контексте алгоритма будет использоваться в качестве синонима к геному.
    Геном состоит изх \textit{генов} — каждый из них содержит информацию о каком-либо признаке (в случае природы) или параметре (в случае ГА).

    В каждый момент времени алгоритм работает с \textit{популяцией} — набором геномов. Полный аналог популяции в природе.
    Мутация — как и в реальной жизни — небольшое случайное изменение генома без строго определённого направления.

    В общих чертах работа ГА выглядит так:

    0. Сгенерировать случайную популяцию, каждый ген каждого генома — в заданных пределах.
    Затем — повторять, пока не закончится заданное количество итераций или не будет достигнуто требуемое значение фитнесс-функции:
    \begin{enumerate}
        \item Посчитать фитнесс-функции для каждой из особей.
        Для большинства задач этот шаг занимает бОльшую часть времени исполнения, поэтому нужно оптимизировать именно его, в частности — параллелизовать, запуская независимые вычисления на нескольких потоках.
        \item Каким-то образом отобрать особи на скрещивание
        \item Произвести скрещивание, получив «отпрысков» — часть нового поколения
        \item Сформировать новое поколение используя, возможно, в разных пропорциях, различные источники геномов, а именно:
                \begin{itemize}
                    \item Отпрысков, полученных на предыдущем шаге в результате скрещивания
                    \item Лучшие особи из прошлой популяции
                    \item Случайные особи — чтобы не дать алгоритму сойтись раньше времени, попав в локальный минимум
                \end{itemize}
    \end{enumerate}

    \section{Авторские Модификации  в ГА}

    Алгоритм реализован мной на языке C++, он хранится в GitHub репозитории \href{https://github.com/donRumata03/Painter}{https://github.com/donRumata03/Painter}.

    \section{Дальнейшее развитие}
    Несмотря на то, что программа уже работоспособна, есть ещё много идей и планов по её усовершенствованию:
    \begin{itemize}
        \item Внедрить \textit{быстрый пересчёт функции ошибки} — это улучшение давно напрашивается,
                но оно несколько теряет в эффективности из-за того, что в одной мутации в среднем изменяется не так мало мазков (однако это количество убывает со временем).
                В настоящий момент ведётся работа над внедрением.
        \item Разделение мазков по слоям.
                Нетрудно заметить, что при рисовании картин художники сначала проходятся по холсту черновыми мазками большого размера, а затем \— прорабатывают детали.
                Таких уровней детализации зачастую бывает немало.

        Пример того, как художник (\href{https://www.youtube.com/watch?v=VaXHtai2alU}{https://www.youtube.com/watch?v=VaXHtai2alU}) рисует картину по слоям:
        \begin{figure}[!htb]
            \centering

            \minipage{0.15\textwidth}
                \includegraphics[width=\linewidth]{../images/painting_example_layer_0.png}
                \caption{Фон, основные цвета}\label{fig:layer0}
            \endminipage\hfill

            \minipage{0.15\textwidth}
                \includegraphics[width=\linewidth]{../images/painting_example_layer_1.png}
                \caption{Рельеф у фона}\label{fig:layer1}
            \endminipage\hfill

            \minipage{0.15\textwidth}
                \includegraphics[width=\linewidth]{../images/painting_example_layer_2.png}
                \caption{Детализация объектов на заднем палане}\label{fig:layer2}
            \endminipage\hfill

            \minipage{0.15\textwidth}
                \includegraphics[width=\linewidth]{../images/painting_example_layer_3.png}
                \caption{Основные объекты}\label{fig:layer3}
            \endminipage\hfill

            \label{fig:figure}
        \end{figure}

                Поэтому стоит попробовать сначала заполнять картинку толстыми, грубыми мазками
                (то есть просто с большей шириной, а в реальной жизни это будет отражаться в большем размере кисти и в более сильном нажатии).
        \item Добавить использование локальных методов оптимизации.
                Такие методы, как \textbf\textit{{градиентный спуск}} и \textbf\textit{{метод Ньютона}} позволяют достичь гораздо большей скорости сходимости
                (в случае метода ньютона — сходимость \href{http://w.ict.nsc.ru/books/textbooks/akhmerov/mo_unicode/4.html}{квадратичная}),
                но требуют умения посчитать градиент функции ошибки в любой точке, а также вектор вторых производных по каждому из аргументов.

                Сами алгоритмы реализованы и находятся в \href{https://github.com/donRumata03/PowerfulGA/blob/master/other_optimization/local_optimization.cpp}{этой папке}.
                Предусмотрена опция подсчёта первой и вторых производных через подстановку близких значений параметров:

                \begin{equation}
                    f'(x_0) \approx \frac{f(x_0 + \Delta x) - f(x_0)}{\Delta x}
                \end{equation}

                Однако в случае с мазками при маленьких изменениях параметров функция ошибки остаётся неизменной, так как это приводит к такому же набору закрашенных пикселей.
                Соответственно, нужно либо радикально увеличивать разрешение изображения, либо использовать аналитические методы.
                То есть нужно математически посчитать изменение функции ошибки при бесконечно малом изменении из параметров функции.


    \end{itemize}

\end{document}