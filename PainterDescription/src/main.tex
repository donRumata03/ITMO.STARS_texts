%! Author = Vova
%! Date = 13.07.2021

% Preamble
\documentclass[11pt]{article}


% Packages
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{polyglossia}
\usepackage{graphicx}
\usepackage{babel,blindtext}
\usepackage{subfig}
\usepackage{iftex}

% Language and Font settings

% Kurale
% New Standard Old
\setdefaultlanguage{russian}
\setmainfont[Ligatures=TeX]{Kurale}
\newfontfamily\cyrillicfont{Kurale}

% Author, date
\title{Описание программной части робота-художника}
\author{Латыпов Владимир Витальевич}
\date{\today}

% Graphics settings
\graphicspath{{../images/}}

% Document
\begin{document}
    \maketitle
    \newpage
    \tableofcontents
    \newpage

    \section{Формулировка задачи}

    Для того, чтобы робот-художник нарисовал что-либо, ему нужно предоставить данные в определённом формате, а именно — не набор пикселей,
    как требуется для показа на мониторе, а набор «мазков»: это связано с конструкцией самого робота.
    Мазки решено было представлять в виде кривых безье второго порядка (то есть квадратичных), к которым добавлены параметры «толщина» и «цвет».

    Но на вход подаются рисунки не в векторном, а в растровом формате.
    Найти такую комбинацию мазков, которая бы лучше всего соответствовала картине/изображению — задача нетривиальная, имеющая множество решений.

    Конечно же, я выбрал решать задачу самостоятельно, а не использовать готовые библиотеки.

    \section{Описание программы в общих чертах}\label{sec:approx_description}
    Таким образом, решено было использовать эвристические алгоритмы оптимизации:
    \href{https://en.wikipedia.org/wiki/Simulated_annealing}{Генетический алгоритм} и \href{https://en.wikipedia.org/wiki/Simulated_annealing}{Симуляция отжига}.

    \subsection{Задание функции ошибки}
    Функцию ошибки необходимо задать таким образом, чтобы она отражала качество полученной комбинации мазков,
    причём в любой точке направление её уменьшения соответствовало направлению улучшения результата.
    Помимо напрашивающегося \href{https://en.wikipedia.org/wiki/Mean_squared_error}{MSE}

    \begin{equation}\label{eq:equation}
        MSE = \sum_{y = 0}^{y < height} { \sum_{x = 0}^{x < width} { \sum_{c \in  \left\{ r, g, b \right\} } { \left( {\overrightarrow {rendered_{x, y}}}_c - {\overrightarrow{original_{x, y}}}_c\right)^2 }}}
    \end{equation}

    , повсеместно используемого при работе с изображениями, функция ошибки «наказывает» наложение мазков, а также

    \subsection{Растеризация мазков}\label{subsec:rasterization}
    Имея мазок, заданный в виде трёх точек на плоскости, толщины и цвета, нужно уметь его отобразить его на «холсте», то есть в виде набора пикселей.
    Это нужно, чтобы подсчитать функцию ошибки для заданного набора мазков.
    Есть много способов произвести растеризацию.

    Самый простой — для некоторого количества точек на кривой Безье (с достаточно маленьким шагом, примерно один пиксель) проводим вертикальную линию: вверх на width и  вниз — тоже.
    Это даёт высокую производительность и сносно выглядит на участках, близких к горизонтальным, но результат, полученный таким способом, очень далёк от реальности на вертикальных участках:
    \begin{figure}[h!]
        \centering
        \includegraphics[width=0.75\textwidth]{stroke_vertical.png}
        \caption{(Красным обозначены точки, задающие кривую)}
        \label{fig:vertical_stroke}
    \end{figure}
    \begin{figure}
        \centering
        \includegraphics[width=0.75\textwidth]{one_stroke.png}
        \caption{Иногда такой способ добавляет свой шарм}
        \label{fig:pretty_vert_stroke}
    \end{figure}

    Есть разные способы избавиться от этих недостатков, сохраняя максимальную производительность.
    Например:
    \begin{itemize}
        \item Совмещать горизонтальные и вертикаьлные полосы
        \item Проводить полосы перпендикулярно направлению кривой в данной точке
    \end{itemize}
    В каждом из них будут наблюдаться пустые места, полости, что недопустимо.

    Ультимативным же способом является подражание реальной жизни: «проведение» круглой «кистью» по экрану.
    То есть берутся точки на кривой на небольшом расстоянии друг от друга, и с центром в каждой из них рисуется круг радиусом width.
    Однако в таком случае каждая точка, попадающая в мазок обрабатывается много раз (для близких кругов), что значительно замедляет рендерниг.
    Если же увеличить шаг, этой проблемы можно частично избежать, но мазок стал бы неровным.
    При маленьком шаге это выглядит так:
    \begin{figure}[h!]
        \centering
        \includegraphics[width=0.75\textwidth]{stroke_smooth.png}
        \label{fig:smooth_stroke}
    \end{figure}

    В будущем планируется улучшить алгоритм для ускорения растеризации при почти том же качестве.
    Рассматриваются варианты:
    \begin{itemize}
        \item Заменить круглую кисть на также гладкую, но с более медленным закруглением с дальней от вектора кривой в данной точке стороны, поворачивая кисть соответствующим образом:
        \begin{figure}
            \centering
            \includegraphics[width=0.75\textwidth]{modern_brush.png}
            \caption{(красным обозначено направление вектора кривой)}
            \label{fig:modern_brush}
        \end{figure}
        Такое изменение поможет уменьшить артефакты при увеличении шага между точками на кривой, то есть позволит сделать шаг больше, ускорив процесс.

        \item Автоматически разбивать мазок на «полигоны».
                    Для этого нужно пройтись по кривой и с некоторым шагом (уже побольше, чем раньше),
                    отметить для каждой рассматриваемой точки на прямой, содержащей её и перпендикулярной текущему направлению, точки в обе стороны от неё на расстоянии width.
                    Каждая из них добавляется в соответствующий стороне в порядке обхода список.
                    Потом полигоны, полученные из соседних точек на кривой и соответствующим им вынесенным точкам, заливаются нужным цветом.
                    На концах же мазка рендерятся круги.

        \begin{figure}
            \centering
            \includegraphics[width=0.75\textwidth]{polygonal_stroke.png}
            \caption{Схема полигональной разбивки мазка}
            \label{fig:polygonal_stroke}
        \end{figure}

        При использовании этого метода никакая существенная часть пикселей мазка не обрабатывается по много раз, что говорит о высокой эффективности алгоритма.
        Поэтому я собираюсь внедрить такой метод в ближайшее время.
    \end{itemize}

    Что же касается совместимости с видеокартой,
    для круга и модифицированной кисти понятно, как определить bouding-box,
    и понятно, как по координатам пикселя быстро определить, принадлежит ли он этому примитиву.
    А рендеринг полигонов, кажется, производится аппаратно.

    \section{Технические аспекты}\label{sec:tecnical}

    \subsection{Основное}\label{subsec:major}
    Программа написана на языке программирования C++(так как требовалась максимальная скорость), сборка осуществляется с помощью CMake.
    Проект можно скомпилировать под Windows (компилятор MSVC) и под Linux (тестировалось на g++-10).

    Код хранится в \href{https://github.com/donRumata03/Painter}{guthub-репозитории (кликабельно)}.

    \subsection{Библиотеки}\label{subsec:libs}

    \subsubsection{OpenCV}
    Для работы с изображениями используется OpenCV, но не модуль машинного обучения, а лишь примитивные операции с изображениями:
    прочтение из популярных форматов, сохранение в них, хранение и копирование матрицы пикселей и т.д.

    \subsubsection{Pythonic}
    Для работы проекта также необходима библиотека «\href{https://github.com/donRumata03/pythonic}{pythonic}»: она написана мной, подключается также через CMake.
    Она отвечает за базовые функции и структуры данных.
    Я использую её во всех более или менее крупных проектах на C++.
    В ней на данный момент есть:
    \begin{itemize}
        \item Простые вспомогательные функции для работы со строками, контейнерами, форматированного вывода
        \item Вызов питоновской библиотеки matplotlib для построения графиков
        \item Базовые алгоритмы наподобие бинарного поиска и дерева отрезков
        \item Функционал для работы со временем, в том числе — анализатор последовательных запусков процесса
        \item Платформонезависимая работа с кодировками и файловыми системами
        \item Примитивы для вычислительной геометрии
        \item Функции для работы со статистикой
        \item Многомерный шаблонный массив с количеством измерений, изменяемом в run-time
        \item Сглаживание функций и построение примерной функции распределения в пространстве с заданной размерностью по набору sampl-ов с помощью гауссовых ворот
        \item Функционал для работы с многопоточностью, в том числе — thread pool, умеющий снимать нагрузку с ожидающих потоков с помощью std::condition\_variable.
    \end{itemize}

    \subsubsection{lunasvg}
    Для работы с SVG используется библиотека \href{https://github.com/sammycage/lunasvg}{lunasvg}.
    P. S. У этой библиотеки отличный автор, он изучает проекты, в которых библиотека используется, и пишет рекомендации о best prictice её использования.

    \subsubsection{PowerfulGA}
    Функционал по методам оптимизации реализован мной и вынесен в отдельную репозиторию: \href{https://github.com/donRumata03/PowerfulGA}{click}
    (там не только Генетический алгоритм, как можно было подумать из названия, но и симуляция отжига, градиентный спуск, метод Ньютона;
    многие другие алгоритмы планируются быть добавленными)
    Более подробное описание в секции $\longrightarrow$ \ref{sec:opimization_algorithms}

    \section {Алгоритмы оптимизации}\label{sec:opimization_algorithms}
    \input{optimization_algorithms}

    \section{Наблюдения}\label{sec:observations}

    \subsection{Неравенство зон}\label{subsec:inequality}
    Когда я заметил, что зоны, на которые Adobe Illustrator делит изображение, могут очень сильно отличаться в размере (отношение площадей может достигать 1000 раз),
    мне захотелось измерить это неравенство численно, чтобы при разработке нового алгоритма измерять его качество в том числе по этому параметру.

    Существует большое количество метрик, я решил выбрать основные из них:
    \begin{itemize}
        \item Индекс Джини (вместе с кумулятивным графиком распределения дохода (также известен как \href{https://en.wikipedia.org/wiki/Lorenz_curve}{кривая Лоренца}))
        \item Процент «дохода» 1\% самых богатых от общего «дохода» (В случае зон вместо дохода используется занимаемая площадь).
        \item Процент самых богатых, имеющих в сумме 50\% от общего дохода.
    \end{itemize}

    Индекс Джини рассчитывается как отношение площади между кривой Лоренца и «линией равенства» к площади под линией равенства.
    Иными словами, $G = \frac{A}{A + B}$ на этой схеме:

    \begin{figure}[h!]\label{fig:lorenz_curve}
        \centering
        \includegraphics[width=0.75\textwidth]{typical_lorenz_curve.png}
        \caption{Типичная кривая Лоренца}
    \end{figure}
    Альтернативный способ посчитать коэффициент, использующийся в реализации:
    \begin{equation}
        G = \frac{\sum_{i=1}^{n}  \sum_{j=i+1}^{n}  \left| y_i - y_j \right|}{n \cdot \sum_{i=1}^{n} y_i}
    \end{equation}
    Чем индекс выше, тем большее неравенство наблюдается в стране.
    Более того, использование именно этой метрики позволяет комплексно оценить неравенство между анализируемыми объектами —
    в отличие от рассмотрения процентов дохода заданного квантиля.


    Результаты оказались впечатляющими:
    \begin{itemize}
        \item $Gini\_index \approx 76\%$
        \item 1\% крупнейших зон покрывают ≈ 18\% изображения
        \item 6.25\% зон покрывают половину изображения
    \end{itemize}

    Так выглядит кумулятивный график распределения площади:
    \begin{figure}[h!]\label{fig:cumulative_inequality_graph}
        \centering
        \includegraphics[width=0.75\textwidth]{cumulative_inequality_graph.jpg}
        \caption{Кривая лоренца для зон}
    \end{figure}

    Нетрудно заметить, что ни в одной стране мира нет такого неравенства, как среди зон:

    \begin{figure}[h!]\label{fig:gini_index_world}
        \centering
        \includegraphics[width=0.75\textwidth]{gini_index_world.jpg}
        \caption{Индекс Джини по странам мира}
    \end{figure}
    Даже в ЮАР индекс Джини составляет 57.8\%.


    \section{Дальнейшее развитие}\label{sec:todo}
    \input{subsequent_development}

\end{document}